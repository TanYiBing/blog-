---
title: javascript异步（一）
date: 2018-09-14 16:06:01
tags:
- JavaScript 
categories:
- JavaScript
---
# JavaScript异步（一）

## 前言

昨天刚立了个flag，而我这个人向来都是说话不算话的（手动滑稽），为了防止自己半途而废，所以今天先来开个头，开了头就不好回头了。

## 异步和单线程有什么关系？

### 1.为啥是单线程
`JavaScript` 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。

JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核CPU的计算能力，HTML5提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。

### 2.啥是异步
我们先看一段代码：

	var i, 
		t = Date.now();
	for (i = 0; i < 100000000; i++) {}
	console.log(Date.now() - t)  // 250

上面的程序花费 250ms 的时间执行完成，执行过程中就会有卡顿，其他的事儿就先撂一边不管了。

执行程序这样没有问题，但是对于 JS 最初使用的环境 ———— 浏览器客户端 ———— 就不一样了。因此在浏览器端运行的js，可能会有大量的网络请求，而一个网络资源啥时候返回，这个时间是不可预估的。这种情况也要傻傻的等着、卡顿着、啥都不做吗？———— 那肯定不行。

因此，JS 对于这种场景就设计了异步 ———— 即，发起一个网络请求，就先不管这边了，先干其他事儿，网络请求啥时候返回结果，到时候再说。这样就能保证一个网页的流程运行。

### 3.事件和回调函数
"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。

### 4.使用回调函数来进行异步操作
举个栗子：

	var ajax = $.ajax({
    	url: '/data/data1.json',
    	success: function () {
        	console.log('success')
    	}
	})

上面这个`ajax`操作就是一个异步操作，第二个参数就是一个callback，我们先发个消息出去取一些数据，当然不会立即就能取到，那我们也不闲着，先去干别的，等拿到了通知我们，我们再执行callback进行数据操作。**实现异步的最核心原理，就是将callback作为参数传递给异步执行函数，当有结果返回之后再触发 callback执行，就是如此简单！**

### 5.常用的异步操作
开发中我们比较常用的异步操作有;

*	网络请求，如 ajax、http
*	IO操作，如 readFile、readDir
*	定时函数：如 setTimeout、setInterval

## Event Loop
**这一部分让我写肯定显得业余，还是去看看阮一峰老师怎么说吧：**[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)

## 事件绑定算不算异步呢？
我们看一个事件绑定的操作：

	$btn.on('click', function (e) {
    	console.log('你点击了按钮')
	})

这个写法和我们上面的异步操作是不是一样，都定义了callback，那事件绑定算不算异步操作呢？如果你认真看了阮一峰老师的那篇文章，你就会发现，其实这也是异步操作。为什么我会这么问呢？

因为它们之间还有有些不同之处的：

*	event-loop 执行时，调用的源不一样。异步操作是系统自动调用，无论是setTimeout时间到了还是$.ajax请求返回了，系统会自动调用。而事件绑定就需要用户手动触发。
*	从设计上来将，事件绑定有着明显的“订阅-发布”的设计模式，而异步操作却没有。

>![](/img/js/4.jpg)

但是我们从这张图上又可以发现,我们的事件包括了`Network`和我们的一些鼠标操作，这些都被认为是异步的。其实仔细想想也对，网络请求其实也相当于订阅和发布啊！

今天的就到这吧！

